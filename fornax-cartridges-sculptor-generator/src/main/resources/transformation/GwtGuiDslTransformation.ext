/*
 * Copyright 2007 The Fornax Project Team, including the original 
 * author or authors.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 
import sculptorguidsl;
import sculptordsl;
import sculptormetamodel;
import sculptorguimetamodel;

extension org::fornax::cartridges::sculptor::dsl::ModelLoadExtensions;
 
extension transformation::DslTransformation;
extension transformation::Transformation;
//extension transformation::DefaultGuiDslTransformation;
//extension transformation::GuiTransformation;
extension transformation::GuiDslTransformation;
extension extensions::helper;
extension extensions::guihelper;
extension extensions::properties;


// For any post-DSL transformations that need to occur
modify(GuiModule guiModule) :
	guiModule.commands.modifyExtends();


// TODO: This will be needed for events as well
// Copied & modified from Transformation.ext
modifyExtends(GuiCommand cmd) :
    if (cmd.extendsName != null) then
        (let matchingDomainObject = findCommandByName(((GuiModule)cmd.eContainer).application, cmd.extendsName) :
        if (matchingDomainObject != null) then
            (cmd.setExtends(matchingDomainObject) ->
            cmd.setExtendsName(null))); 

// Copied & modified from Transformation.ext
private DomainObject findCommandByName(GuiApplication app, String domainObjectName) : 
    let match = app.modules.commands.select(e | e.name == domainObjectName) : 
    match.isEmpty ? null : match.first();



//
// Service proxy-related transformations
//

// TODO: For next two methods, is there something I can use that immediately returns first?
Service getMetamodelService(DslGuiServiceDependency dslServiceDep, Module module) :
	module.services.select(s | s.name == dslServiceDep.dependency.name).first();

DomainObject getDomainObject(DslGuiDto dslGuiDto, Module module) :
	module.domainObjects.select(d | d.name == dslGuiDto.for.name).first();

/*
create sculptorguimetamodel::ServiceProxy this transformServiceProxy(DslGuiServiceDependency dslServiceDep, Module module) :
	let domainService = getMetamodelService(dslServiceDep, module) :
	setFor(domainService) ->
	setName(domainService.name) ->
	setDoc(domainService.doc) ->
	setModule(this.for.module) ->
	operations.addAll(domainService.operations.select(o | dslServiceDep.dependency.operations.exists(e|e.name == o.name)).transformServiceProxyOperation(this)) ->
	debugTrace("transformServiceProxy: service = " + domainService) ->
	debugTrace("transformServiceProxy: module = " + module) ->
	debugTrace("transformServiceProxy: domain service module = " + this.for.module);
*/


create sculptorguimetamodel::ServiceProxy this transformServiceProxy(DslGuiServiceDependency dslServiceDep, Module module) :
	let domainService = getMetamodelService(dslServiceDep, module) :
		setFor(domainService) ->
		setName(domainService.name) ->
		setDoc(domainService.doc) ->
		setModule(module) ->
		operations.addAll(domainService.operations.select(o | dslServiceDep.dependency.operations.exists(e|e.name == o.name)).transformServiceProxyOperation(this));

//create sculptorguimetamodel::ServiceProxy this transformServiceProxy(Service domainService, Module module) :
//	debugTrace("transformServiceProxy: service = " + domainService) ->
//	debugTrace("transformServiceProxy: module = " + module) ->
//	setFor(domainService) ->
//	setName(domainService.name) ->
//	setDoc(domainService.doc) ->
//	setModule(module) ->
//	debugTrace("transformServiceProxy: this module = " + this.module) ->
//	operations.addAll(domainService.operations.select(o | domainService.operations.exists(e|e.name == o.name)).transformServiceProxyOperation(this));


// 	operations.addAll(domainServiceOp.operations.transformServiceProxyOperation());
create sculptorguimetamodel::GuiDto this transformGuiDto(DomainObject domainObj) :
	setFor(domainObj) ->
    setDoc(domainObj.doc) ->
    setName(domainObj.name) ->
    setPackage(domainObj.package) ->
//	setModule(domainObj.module) ->
    setAbstract(domainObj.abstract) ->
    setOptimisticLocking(domainObj.optimisticLocking) ->
    setValidate(domainObj.validate) ->
    setHint(domainObj.hint) ->
    setGapClass(domainObj.gapClass) ->
    attributes.addAll(domainObj.attributes.copy()) ->
    references.addAll(domainObj.references.copy()) ->
    operations.addAll(domainObj.operations.copy()) ->
    setExtends(domainObj.extends != null ? domainObj.extends.transformGuiDto() : null) ->
//    traits.addAll(domainObject.traits.transform());
	debugTrace("Done with " + domainObj.name);


create sculptormetamodel::Attribute this copy(sculptormetamodel::Attribute attribute) :
    setDoc(attribute.doc) ->
    setName(attribute.name) ->
    setType(attribute.type) ->
    setCollectionType(attribute.collectionType) ->
    setNaturalKey(attribute.naturalKey) ->
    setChangeable(attribute.changeable) ->
    setRequired(attribute.required) ->
    setNullable(attribute.nullable) ->
    setLength(attribute.length) ->
    setValidate(attribute.validate) ->
    setHint(attribute.hint) ->
    setTransient(attribute.transient) ->
    setVisibility(attribute.visibility);
//	debugTrace("Done with attr " + attribute.name);

create sculptormetamodel::Reference this copy(sculptormetamodel::Reference reference) :
	setFrom(((DslSimpleDomainObject) reference.eContainer).transformGuiDto()) ->
    setDoc(reference.doc) ->
    setName(reference.name) ->
    setCollectionType(reference.collectionType) ->
    setMany(reference.many) ->
    setNaturalKey(reference.naturalKey) ->
    setChangeable(reference.changeable) ->
    setRequired(reference.required) ->
    setNullable(reference.nullable) ->
    setInverse(reference.inverse) ->
    setOrderBy(reference.orderBy) ->
    setTo(reference.to.transformGuiDto()) ->
    setValidate(reference.validate) ->
    setHint(reference.hint) ->
    setTransient(reference.transient) ->
    setVisibility(reference.visibility) ->
    setOpposite(reference.opposite == null? null : reference.opposite.copy());
//	debugTrace("Done with ref " + reference.name);
 	
 
 create sculptormetamodel::DomainObjectOperation this copy(DomainObjectOperation operation) :
	setDomainObject(((DslDomainObject) operation.eContainer).transformGuiDto()) ->
    setDoc(operation.doc) ->
    setName(operation.name) ->
    setAbstract(operation.abstract) ->
    setVisibility(operation.visibility) ->
    parameters.addAll(operation.parameters.copy()) ->
    setCollectionType(operation.collectionType) ->
    setMapKeyType(operation.mapKeyType) ->
    setType(operation.type) ->
    setDomainObjectType(operation.domainObjectType == null ? null : operation.domainObjectType.transformGuiDto()) ->
    setThrows(operation.throws) ->
    setHint(operation.hint);
//	debugTrace("Done with op " + operation.name);

create sculptormetamodel::Parameter this copy(sculptormetamodel::Parameter parameter) :
    setName(parameter.name) ->
    setDoc(parameter.doc) ->
    setCollectionType(parameter.collectionType) ->
    setMapKeyType(parameter.mapKeyType) ->
    setType(parameter.type) ->
    setDomainObjectType(parameter.domainObjectType == null ? null :
    	parameter.domainObjectType.transformGuiDto());

    
// Copied from DslTransformation.ext
private String convertVisibility(DslVisibility dslVisibility) :
	dslVisibility == null ?
		"public" :
		dslVisibility.toString();

private String convertCollectionType(DslComplexType dslComplexType) :
	if (dslComplexType == null) then
		null
	else if (dslComplexType.mapCollectionType != null) then
		dslComplexType.mapCollectionType
	else
		convertCollectionTypeEnum(dslComplexType.collectionType);
		
private String convertCollectionTypeEnum(DslCollectionType collectionType) :
	if (collectionType == null || collectionType == DslCollectionType::None) then
		null
	else
		collectionType.toString();

// End of Copied from DslTransformation.ext

 	
create sculptorguimetamodel::ServiceProxyOperation this transformServiceProxyOperation(ServiceOperation domainOperation,
	Service service) :
//	setService(((DslService) operation.eContainer).transform()) ->
	debugTrace("transformServiceProxyOperation: name=" + domainOperation.name ) ->
	setService(service) ->
	debugTrace("transformServiceProxyOperation: service=" + this.service) ->
	debugTrace("transformServiceProxyOperation: service.module=" + this.service.module) ->
	setFor(domainOperation) ->
    setDoc(domainOperation.doc) ->
    setName(domainOperation.name) ->
    setVisibility(domainOperation.visibility) ->
    parameters.addAll(domainOperation.parameters.reject(p | p.type == "org.fornax.cartridges.sculptor.framework.errorhandling.ServiceContext").transformGwtServiceOperationParam()) ->
    setCollectionType(domainOperation.collectionType) ->
    setMapKeyType(domainOperation.mapKeyType) ->
    setType(domainOperation.type) ->
    setDomainObjectType(domainOperation.domainObjectType) ->
    setThrows(domainOperation.throws) ->
    setHint(domainOperation.hint) ->
	debugTrace("transformServiceProxyOperation: this=" + this );


Parameter transformGwtServiceOperationParam(Parameter param) :
	let newParam = new Parameter :
		newParam.setCollectionType(param.collectionType) ->
		newParam.setDoc(param.doc) ->
		newParam.setDomainObjectType(param.domainObjectType) ->
		newParam.setHint(param.hint) ->
		newParam.setMapKeyType(param.mapKeyType) ->
		newParam.setName(param.name) ->
		newParam.setType(param.type);

//
// View related transformations
//

// TODO: Put a validation check here to ensure the service (serviceDependency) is actually in the contained module.  Right now it's a silent failure
create sculptorguimetamodel::View this transformView(DslView view, Module module) :
	let domainObject = module.domainObjects.select(e | e.name == view.for.name).first() :
	debugTrace("======================================================= transforming view! " + view.name) ->
	setDoc(view.doc) ->
	setName(view.name) ->
	setFor(domainObject) ->
	parameters.addAll(view.parameters.transform()) ->
	widgets.addAll(view.widgets.transformWidget(module)) ->
	setModule(((DslGuiModule) view.eContainer).transformModule()) ->
//	debugTrace("transformView: module = " + module ) ->
//	serviceProxies.addAll(view.serviceDependencies.getMetamodelService(module).transformServiceProxy(module, dslModule));
	serviceProxies.addAll(view.serviceDependencies.transformServiceProxy(module));
	

create sculptorguimetamodel::ViewParameter this transform(DslViewParameter dslParam) :
	setDoc(dslParam.doc) ->
	setName(dslParam.name) ->
	setType(dslParam.type) ->
	setNullable(dslParam.nullable);



//////////////////////////////////////////////////////////////////////////////////
// GuiEvent related transformations
//////////////////////////////////////////////////////////////////////////////////
	
create sculptorguimetamodel::Widget this transformWidget(DslWidget widget, Module module) :
	error("Unexpected call to transformWidget(DslWidget): " + widget);

create sculptorguimetamodel::LinkWidget this transformWidget(DslLinkWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setToView(widget.toView == null ? null : widget.toView.transformView(((DslGuiModule)(widget.toView.eContainer)).for.transform())) ->
	setName(widget.name) ->
	setLabel(widget.label);

		
create sculptorguimetamodel::NumberSpinnerWidget this transformWidget(DslNumberSpinnerWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setDoc(widget.doc) ->
	setName(widget.name) ->
	setLabel(widget.label);

create sculptorguimetamodel::InputDateWidget this transformWidget(DslInputDateWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setDoc(widget.doc) ->
	setName(widget.name) ->
	setLabel(widget.label);

create sculptorguimetamodel::RichTextAreaWidget this transformWidget(DslRichTextAreaWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setDoc(widget.doc) ->
	setName(widget.name) ->
	setLabel(widget.label);

create sculptorguimetamodel::RadioButtonsWidget this transformWidget(DslRadioButtonsWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setDoc(widget.doc) ->
	setName(widget.name) ->
	setLabel(widget.label);

create sculptorguimetamodel::AutocompleteWidget this transformWidget(DslAutocompleteWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setDoc(widget.doc) ->
	setName(widget.name) ->
	setLabel(widget.label);

create sculptorguimetamodel::InputTextWidget this transformWidget(DslInputTextWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setDoc(widget.doc) ->
	setName(widget.name) ->
	setForProperty(widget.forProperty == null ? null : widget.forProperty.transformSourceRef()) ->
	setLabel(widget.label);

create sculptorguimetamodel::ViewAttributeReference this transformSourceRef(DslAnyProperty prop) :
	debugTrace("Got prop " + prop.name);
	
create sculptorguimetamodel::TextAreaWidget this transformWidget(DslTextAreaWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setDoc(widget.doc) ->
	setName(widget.name) ->
	setLabel(widget.label);

	
create sculptorguimetamodel::ButtonWidget this transformWidget(DslButtonWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setDoc(widget.doc) ->
	setName(widget.name) ->
	setLabel(widget.label);
	
create sculptorguimetamodel::InformationalTextWidget this transformWidget(DslInformationalTextWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setDoc(widget.doc) ->
	setName(widget.name) ->
	setLabel(widget.label);
	
create sculptorguimetamodel::TableWidget this transformWidget(DslTableWidget widget, Module module) :
	let view = ((DslView) widget.eContainer).transformView(module) :
	let domainObject = module.domainObjects.select(e | e.name == widget.for.name).first() :
	setView(view) ->
	setDoc(widget.doc) ->
	debugTrace("********************************************** transforming " + widget.name) ->
	setName(widget.name) ->
	setLabel(widget.label) ->
	setFor(domainObject) ->
	columns.addAll(widget.columns.transformColumn(module));

create sculptorguimetamodel::TableColumn this transformColumn(DslTableColumn col, Module module) :
	setName(col.name)->
	setLabel(col.label) ->
	setColumnType(col.columnType) ->
	setSortable(col.sortable) ->
	setFilterable(col.filterable) ->
	behaviorBindings.addAll(col.behaviorBindings.transform(module));

create sculptorguimetamodel::PanelWidget this transformWidget(DslPanelWidget widget, Module module) :
	setView(((DslView) widget.eContainer).transformView(module)) ->
	setDoc(widget.doc) ->
	setName(widget.name) ->	
	setLabel(widget.label) ->
	setFor(widget.for == null ? null : widget.for.transform()) ->
	widgets.addAll(widget.widgets.transformWidget(module));
	


//////////////////////////////////////////////////////////////////////////////////
// GuiEvent related transformations
//////////////////////////////////////////////////////////////////////////////////

create sculptorguimetamodel::GuiEvent this transformEvent(DslGuiEvent event, Module module) :
	setGuiModule(((DslGuiModule) event.eContainer).transformModule()) ->
	setName(event.name) ->
	setDoc(event.doc) ->
	attributes.addAll(event.attributes.transformAttribute(module));
	
create sculptormetamodel::Attribute this transformAttribute(DslGuiAttribute attr, Module module) :
//	setEvent(((DslEvent) attr.eContainer).transformEvent(module)) ->
	setName(attr.name) ->
	setDoc(attr.doc) ->
	setType(attr.type.translateGwtTypeName());
	


//////////////////////////////////////////////////////////////////////////////////
// GuiCommand related transformations
//////////////////////////////////////////////////////////////////////////////////
create sculptorguimetamodel::GuiCommand this transformCommand(DslCommandEvent dslCmd, Module module) :
	setName(dslCmd.name) ->
	setAbstract(dslCmd.abstract) ->
	setExtends( dslCmd.extends != null ? dslCmd.extends.transformCommand(module) : null) ->
	setExtendsName( dslCmd.extendsName != null ? dslCmd.extendsName : null) ->
	setDoc(dslCmd.doc) ->
	setHint(dslCmd.hint) ->
	attributes.addAll(dslCmd.attributes.transformToGwt()) ->
	references.addAll(dslCmd.references.transformToGwt(this))
	;
	
	
create sculptormetamodel::Attribute this transformToGwt(DslAttribute attribute) :
    setDoc(attribute.doc) ->
    setName(attribute.name) ->
    setType(attribute.type) ->
    setCollectionType(convertCollectionTypeEnum(attribute.collectionType)) ->
    setChangeable(!attribute.notChangeable) ->
    setRequired(attribute.required) ->
    setNullable(attribute.nullable) ->
    setLength(attribute.length) ->
    setValidate(attribute.handleValidation()) ->
    setHint(attribute.hint) ->
    setTransient(attribute.transient) ->
    setVisibility(convertVisibility(attribute.visibility));

create sculptormetamodel::Reference this transformToGwt(DslReference reference, DomainObject owner) :
	setFrom(owner) ->
    setDoc(reference.doc) ->
    setName(reference.name) ->
    setCollectionType(convertCollectionTypeEnum(reference.collectionType)) ->
    setMany(reference.collectionType != null && reference.collectionType != DslCollectionType::None) ->
    setChangeable(!reference.notChangeable) ->
    setRequired(reference.required) ->
    setNullable(reference.nullable) ->
    setInverse(reference.inverse) ->
    setCascade(reference.cascade) ->
    setFetch(reference.fetch) ->
    setOrderBy(reference.orderBy) ->
    setTo(reference.domainObjectType.transform()) ->
    setValidate(reference.handleValidation()) ->
    setHint(reference.hint) ->
    setTransient(reference.transient) ->
    setVisibility(convertVisibility(reference.visibility)) ->
    (reference.oppositeHolder != null && reference.oppositeHolder.opposite != null ?
      setOpposite(reference.oppositeHolder.opposite.transform()):
      null)
    ;


//////////////////////////////////////////////////////////////////////////////////
// UiBehavior related transformations
//////////////////////////////////////////////////////////////////////////////////

create sculptorguimetamodel::UiBehavior this transformBehavior(DslUiBehavior behavior, Module module) :
	error("Unexpected call to transformBehavior(DslUiBehavior)");

create sculptorguimetamodel::PopulatePanelBehavior this transformBehavior(DslPopulatePanelBehavior behavior, Module module) :
	setDoc(behavior.doc) ->
	setName(behavior.name) ->
	setPanel(behavior.panel.transformWidget(module));
	
create sculptorguimetamodel::BehaviorBinding this transform(DslBehaviorBinding binding, Module module) :
	error("Unexpected call to transform(DslBehaviorBinding)");
	
create sculptorguimetamodel::OnClickBinding this transform(DslOnClick binding, Module module) :
	behaviors.addAll(binding.behaviors.transformBehavior(module));

create sculptorguimetamodel::OnHoverBinding this transform(DslOnHover binding, Module module) :
	behaviors.addAll(binding.behaviors.transformBehavior(module));
	
		
//////////////////////////////////////////////////////////////////////////////////
// Transformation helper functions.  Currently overlapped with sofeauihelpers.ext
//////////////////////////////////////////////////////////////////////////////////
String translateGwtTypeName(String typeStr) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.translateGwtTypeName(java.lang.String);

	
	
//////////////////////////////////////////////////////////////////////////////////
// DSL transformation helper functions.  Currently overlapped with DslTransformation.ext
//////////////////////////////////////////////////////////////////////////////////
private String convertCollectionTypeEnum(DslCollectionType collectionType) :
	if (collectionType == null || collectionType == DslCollectionType::None) then
		null
	else
		collectionType.toString();

private String handleValidation(DslAttribute attribute) :
    ((attribute.validate != null) ? attribute.validate : "") +
	handleParameterizedAnnotation("range", "min,max,message", attribute.range, attribute.validate) +
	handleParameterizedAnnotation("length", "max,min,message", attribute.length, attribute.validate) +
	handleParameterizedAnnotation("digits", "integerDigits,fractionalDigits,message", attribute.digits, attribute.validate) +
//	handleParameterizedAnnotation("size", "min,max,message", attribute.size, attribute.validate) +
	handleBooleanAnnotation("assertTrue", attribute.assertTrue, attribute.assertTrueMessage, attribute.validate) +
	handleBooleanAnnotation("assertFalse", attribute.assertFalse, attribute.assertFalseMessage, attribute.validate) +
	handleBooleanAnnotation("creditCardNumber", attribute.creditCardNumber, attribute.creditCardNumberMessage, attribute.validate) +
	handleBooleanAnnotation("ean", attribute.ean, attribute.eanMessage, attribute.validate) +
	handleBooleanAnnotation("email", attribute.email, attribute.emailMessage, attribute.validate) +
	handleBooleanAnnotation("notNull", !attribute.nullable && !attribute.type.isPrimitiveType(), attribute.nullableMessage, attribute.validate) +
	handleBooleanAnnotation("notEmpty", attribute.notEmpty, attribute.notEmptyMessage, attribute.validate) +
	handleBooleanAnnotation("future", attribute.future, attribute.futureMessage, attribute.validate) +
	handleBooleanAnnotation("past", attribute.past, attribute.pastMessage, attribute.validate) +
	handleSimpleAnnotation("min", attribute.min, attribute.validate) +
	handleSimpleAnnotation("max", attribute.max, attribute.validate) +
	// TODO: add missing parameter 'flags', needs special handling
	handleParameterizedAnnotation("pattern", "regex,message", attribute.pattern, attribute.validate)
	// TODO: add support for 'patterns' annotation
	;

private String handleValidation(DslReference reference) :
    ((reference.validate != null) ? reference.validate : "") +
	handleParameterizedAnnotation("size", "min,max,message", reference.size, reference.validate) +
	handleBooleanAnnotation("notNull", !reference.nullable, reference.nullableMessage, reference.validate) +
	handleBooleanAnnotation("notEmpty", reference.notEmpty, reference.notEmptyMessage, reference.validate) +
	handleBooleanAnnotation("valid", reference.valid, reference.validMessage, reference.validate)
	;

private String handleParameterizedAnnotation(String annotation, String parameterNames, String parameters, String validate) :
	JAVA org.fornax.cartridges.sculptor.generator.util.GenerationHelper.handleParameterizedAnnotation(java.lang.String, java.lang.String, java.lang.String, java.lang.String);

private String handleSimpleAnnotation(String annotation, String value, String validate) :
	JAVA org.fornax.cartridges.sculptor.generator.util.GenerationHelper.handleSimpleAnnotation(java.lang.String, java.lang.String, java.lang.String);

private String handleBooleanAnnotation(String annotation, Boolean value, String message, String validate) :
	JAVA org.fornax.cartridges.sculptor.generator.util.GenerationHelper.handleBooleanAnnotation(java.lang.String, java.lang.Boolean, java.lang.String, java.lang.String);

private String convertVisibility(DslVisibility dslVisibility) :
	dslVisibility == null ?
		"public" :
		dslVisibility.toString();



	