import sculptormetamodel;
import sculptorguimetamodel;

extension extensions::properties;
extension extensions::helper;
extension extensions::guihelper;


String testoid() :
	"test";

// Get all of the Services that are used, either at the module or view level
Set[Module] getAllUsedServices(sculptorguimetamodel::GuiModule guiModule) :
	let list = {} :
		list.addAll(guiModule.views.getUsedServices().toSet().select(s|s != null)) ->
		list.addAll(guiModule.getUsedServices()) ->
		list.toSet();
//	debugTrace("all services list: " + list) ->

String getEnumCommonInterfaces(Enum enumObj) :
	"java.io.Serializable" + (hasProperty("gwt.enum.common.interfaces") ? "," + getProperty("gwt.enum.common.interfaces") : "");

String getGwtInterfaceHasSelection(Widget widget) :
	getGwtInterface("hasselection") + "<" + widget.getTypedWidgetTargetType() + ">";



Boolean gwtDtoGenerateGap(GuiDto guiDto) :
	getBooleanProperty("gwt.dto.generate.gap") || guiDto.hasHint("gwtgap");

String baseClassName(DomainObject domainObject) :
  domainObject.name + (domainObject.gapClass && domainObject.gwtDtoGenerateGap() ? "Base" : "");

String getGwtExtendsLitteral(DomainObject domainObject) :
	domainObject.getGwtExtendsClassName() == "" ?
		"" :
     	"extends " + domainObject.getGwtExtendsClassName();

String getGwtExtendsClassName(DomainObject domainObject) :
    (domainObject.extends == null) ?
        (domainObject.extendsName == null ? domainObject.gwtDefaultExtendsClassName() : domainObject.extendsName) :
        domainObject.extends.gwtDomainPackage() + "." + domainObject.extends.name;

// See getDomainPackage() in helper.ext - this is here to specialize the package returned for GuiDtos
cached String getDomainPackage(GuiDto domainObject) :
	domainObject.gwtDomainPackage();


String getGwtExtendsClassName(GuiCommand domainObject) :
    (domainObject.extends == null) ?
        (domainObject.extendsName == null ? domainObject.gwtDefaultExtendsClassName() : domainObject.extendsName) :
        domainObject.extends.gwtCommandPackage() + "." + domainObject.extends.name;

String gwtDefaultExtendsClassName(DomainObject domainObject) :
	let result = defaultExtendsClass(domainObject.simpleMetaTypeName()) :
	(result == "" ? abstractDomainObjectClass() : result);



String gwtDefaultExtendsClassName(DataTransferObject domainObject) :
	defaultExtendsClass(domainObject.simpleMetaTypeName());
	
String gwtDefaultExtendsClassName(Trait domainObject) :
	defaultExtendsClass(domainObject.simpleMetaTypeName());

String gwtDefaultExtendsClassName(GuiCommand domainObject) :
	let result = defaultExtendsClass(domainObject.simpleMetaTypeName()) :
	(result == "" ? abstractGwtCommandClass() : result);

String abstractGwtCommandClass() :
	fw("gwt.shared.domain.AbstractGwtCommand");
	
String gwtSubPackage() :
	getProperty("package.gwt");



String gwtFrameworkPresenterBaseInterface() :
	getProperty("gwt.presenter.base.interface");


//String getGwtDtoPackage(GuiApplication guiApp) :
//    guiApp.basePackage + "." + subPackage("shared");

//String getGwtDtoPackage(GuiModule guiMod) :
//    guiMod.application.basePackage +  "." + "shared";

	
String getFieldUniqueCssId(ViewDataProperty property) :
    property.userTask.name + property.name.toFirstUpper() + "Field";


String gwtBasePackage(GuiModule module) :
	gwtBasePackage(module.stubModule);

String gwtBasePackage(StubModule module) :
	(module.basePackage != null ? module.basePackage : module.guiModule.application.basePackage + "." + module.name) + "." + gwtSubPackage(); 
   

// Get the GWT base package for the given GUI module (up-to & including .gwt)
String getGwtPackage(GuiModule guiModule) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.getGwtPackage(sculptorguimetamodel.GuiModule);


String gwtDomainPackage(StubModule module) :
   let res = gwtBasePackage(module) + ".shared.domain":
//   debugTrace("gwtDomainPackage() res=" + res) ->
   res;

String gwtDomainPackage(GuiModule module) :
   getGwtPackage(module) + ".shared.domain";

String gwtCommandPackage(GuiCommand cmd) :
	gwtBasePackage((StubModule)cmd.eContainer) + ".shared.command";
//   getGwtPackage((GuiModule)cmd.eContainer) + ".shared.command";

// TODO: No longer used?
String gwtCommandPackage(CommandEvent cmd) :
   gwtBasePackage(cmd.module) + ".shared.command";

//String gwtDomainPackage(Enum enum) :
//   gwtDomainPackage(do.module);


// TODO: Remove
String gwtDomainPackage(DomainObject do) :
   gwtDomainPackage(do.module);

String gwtDomainPackage(GuiDto do) :
	debugTrace("gwtDomainPackage(" + do + ") : guiModule = " + do.guiModule) ->
   gwtDomainPackage(do.guiModule.stubModule);

//String gwtDomainPackage(GuiCommand do) :
//   gwtDomainPackage(do.guiModule.stubModule);

String fqnGwtDto(Reference ref) :
	gwtDomainPackage(ref.to) + "." + ref.to.name;
	
// The fully qualified name for the domain class (not GWT DTO).
String fqnDomain(GuiDto do) :
//	debugTrace("fqnDomain(" + do + ")") ->
	do.for.getDomainPackage() + "." + do.name;

String fqnDomain(Reference ref) :
	fqnDomain(ref.to);


// The fully qualified GWT DTO class for a given domain object
String fqnGwtDto(GuiDto do) :
//	debugTrace("fqnGwtDto(" + do + ")") ->
	do.gwtDomainPackage() + "." + do.name;

String fqnGwtDto(GuiEnum enum) :
	enum.gwtDomainPackage() + "." + enum.name;
	

String fqnGwtDto(GuiCommand do) :
	do.gwtCommandPackage() + "." + do.name;
	
// TODO: No longer used?
String fqnGwtDto(CommandEvent do) :
	do.gwtCommandPackage() + "." + do.name;

Collection[Attribute] getGwtDtoAttributes(DomainObject domainObject) :
	domainObject.attributes.select(attr|attr.generateGwt() && attr.name != "createdDate" && attr.name != "createdBy" && attr.name != "lastUpdated" && attr.name != "lastUpdatedBy");

Collection[Attribute] getAllBusinessAttributes(DomainObject domainObject) :
	domainObject.getAllAttributes().select(attr|attr.generateGwt() && attr.name != "id" && attr.name != "occurred" && attr.name != "recorded" 
		&& attr.name != "createdBy" && attr.name != "createdDate" && attr.name != "lastUpdated" && attr.name != "lastUpdatedBy");

Collection[Reference] getAllBusinessReferences(DomainObject domainObject) :
	domainObject.getAllReferences().select(r| r.generateGwt());


// Get all the view data properties to be be displayed/edited..  Note this leaves out referred-to domain classes, including things like Plan Type
Collection[ViewDataProperty] getAllBusinessViewDataProperties(UserTask task) :
	task.viewProperties.reject(p | p.metaType == ReferenceViewProperty || p.metaType == DerivedReferenceViewProperty || p.isSystemAttribute() || p.name == "version");

////////////////////////////////////////////////////////////////
// DTO Builder related methods
////////////////////////////////////////////////////////////////

String getGwtDtoBuilderPackage(GuiDto do) :
	do.gwtDomainPackage();

String getGwtDtoBuilderFqn(GuiDto do) :
	do.getGwtDtoBuilderPackage() + "." + do.name + "Builder";
	
String getDomainBuilderFqn(GuiDto do) :
	getBuilderFqn(do.for);

/////////////////////////////////////////////////////////////////////
// Async interface helpers
/////////////////////////////////////////////////////////////////////
	
gwtServiceAsyncInterfaceName(Service svc) :
	"Gwt" + svc.name + "Async";
	
gwtServiceAsyncInterfacePackage(ServiceProxy svc) :
	gwtBasePackage(svc.guiModule) + ".client";
	
gwtServiceAsyncInterface(ServiceProxy svc) :
	gwtServiceAsyncInterfacePackage(svc) + "." + gwtServiceAsyncInterfaceName(svc);

// TODO: Get rid of the following once view service dependencies use ServiceProxy instead
gwtServiceAsyncInterface(Service svc) :
	gwtServiceAsyncInterfacePackage(svc) + "." + gwtServiceAsyncInterfaceName(svc);

// Sync interface helpers
	
gwtServiceSyncInterfaceName(ServiceProxy svc) :
	"Gwt" + svc.name;
	
gwtServiceSyncInterfacePackage(ServiceProxy svc) :
	gwtBasePackage(svc.guiModule) + ".client";

	
gwtServiceSyncInterface(ServiceProxy svc) :
	gwtServiceSyncInterfacePackage(svc) + "." + gwtServiceSyncInterfaceName(svc);

// Service impl helpers
	
gwtServiceImplName(ServiceProxy svc) :
	"Gwt" + svc.name + "Impl";
	
gwtServiceImplPackage(ServiceProxy svc) :
	gwtBasePackage(svc.guiModule) + ".server";
	
gwtServiceImpl(ServiceProxy svc) :
	gwtServiceImplPackage(svc) + "." + gwtServiceImplName(svc);

gwtServiceImplFqn(ServiceProxy svc) :
//	debugTrace("Module: " + svc.module) ->
	gwtServiceImplPackage(svc) + "." + gwtServiceImplName(svc);

String getGwtParameterTypeName(Parameter e, Module module) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.getParamaterTypeName(sculptormetamodel.Parameter, sculptormetamodel.Module);

// Get GWT DTO type name corresponding to given typed element (e.g. operation with return type)
String getGwtTypeName(DomainObjectTypedElement e) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.getTypeName(sculptormetamodel.DomainObjectTypedElement);
    
String getGwtTypeName(Reference ref) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.getTypeName(sculptormetamodel.Reference);

String getGwtTypeName(TypedElement e) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.getTypeName(sculptormetamodel.TypedElement);

String getGwtTypeName(NamedElement e) :
	error("getGwtTypeName(NamedElement) called, which means the following object was unexpected: " + e) ->
	null;

String translateGwtType(TypedElement e) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.translateGwtType(sculptormetamodel.TypedElement);

String translateGwtTypeName(String typeStr) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.translateGwtTypeName(java.lang.String);

// Get Domain type name corresponding to the given GuiDto
String getGuiDomainTypeName(GuiDto guiDto) :
	guiDto.for.typeName;

// Get Domain type name corresponding to the given GuiDto-based typed element
String getGuiDomainTypeName(DomainObjectTypedElement e) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.getGuiDomainTypeName(sculptormetamodel.DomainObjectTypedElement);

//String translateGwtTypeName(DslGuiAttribute) :
//    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.translateGwtTypeName(sculptormetamodel.Attribute, java.lang.String);


//attr.translateGwtTypeName



String getGwtTypeName(ViewDataProperty prop) :
	null;

String getGwtTypeName(AttributeViewProperty prop) :
	prop.attribute.getGwtTypeName();

String getGwtTypeName(BasicTypeViewProperty prop) :
	prop.attribute.getGwtTypeName();



String getGwtImplTypeName(TypedElement e) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.getImplTypeName(sculptormetamodel.TypedElement);


    
// Package for all view-related widget classes, non-generated source
gwtWidgetsPackage(View view) :
	getGwtPackage(view.module) + ".client.view";

// Package for all view-related widget classes, non-generated source
gwtBaseWidgetsPackage(View view) :
	getGwtPackage(view.module) + ".client.gen.view";



// Package for all task-related widget classes
gwtWidgetsPackage(UserTask task) :
	gwtBasePackage(task.for) + ".client";

// Get the template file path given the fqn of the corresponding widget class 
String gwtTemplateFilePath(String widgetClassFqn) :
    widgetClassFqn.replaceAll("\\.", "/") + ".ui.xml";



// Fully qualified name of GWT table widget class corresponding to the given task
String fqnGwtTableWidgetClass(ListTask task) :
	task.gwtWidgetsPackage() + "." + task.gwtTableWidgetClass() ;

// GWT table widget class relative name
String gwtTableWidgetClass(ListTask task) :
	plural(task.for.name) + "Table";


// Name of attribute for table column
String tableColumnAttrName(TableColumn column) :
	((TableWidget)column.eContainer).name + column.name.toFirstUpper() + "TableCol";


// Fully qualified name of GWT table widget base class corresponding to the given task
String fqnGwtTableWidgetBaseClass(ListTask task) :
	task.gwtWidgetsPackage() + "." + task.gwtTableWidgetBaseClass() ;


// GWT table widget class relative name
String gwtTableWidgetBaseClass(ListTask task) :
	plural(task.for.name) + "TableBase";

// Get the table template file path for the given List task
String gwtTableTemplateFilePath(ListTask task) :
	gwtTemplateFilePath(fqnGwtTableWidgetBaseClass(task));
	








// GWT edit form widget class relative name
String gwtEditFormWidgetBaseClass(UserTask task) :
	task.for.name + "EditFormBase";

// Fully qualified name of GWT edit form widget base class corresponding to the given task
String fqnGwtEditFormWidgetBaseClass(UserTask task) :
	task.gwtWidgetsPackage() + "." + task.gwtEditFormWidgetBaseClass() ;
	
// Get the edit form base template file path for the given  task
String gwtEditFormBaseTemplateFilePath(UserTask task) :
	gwtTemplateFilePath(fqnGwtEditFormWidgetBaseClass(task));
	
	
String getAttributeType(ViewDataProperty prop) :
	null;

String getAttributeType(AttributeViewProperty prop) :
	prop.attribute.type;

String getAttributeType(BasicTypeViewProperty prop) :
	prop.attribute.type;

	
String resolveGwtWidgetType(ViewDataProperty prop) :
	if (prop.isDateOrDateTime()) then
		"com.google.gwt.user.datepicker.client.DateBox" // com.google.gwt.user.datepicker.client.DateBox
	else if (prop.isBoolean()) then
		"com.google.gwt.user.client.ui.CheckBox"
	else 
		"com.google.gwt.user.client.ui.TextBox";




///////////////////////////////////////////////////////////////
// TableWidget-related functions
///////////////////////////////////////////////////////////////

boolean usesAsyncDataProvider(TableWidget tableWidget) :
	(tableWidget.paging ? true : false);

String fqnDataProviderClass(TableWidget tableWidget) :
	tableWidget.usesAsyncDataProvider() ? getProperty("gwt.dataprovider.async.class") : getProperty("gwt.dataprovider.list.class");

// Relative name of the DTO class that a table is for
DomainObject tableForClass(TableWidget table) :
	table.for;

// Fully qualified name of the DTO class that a table is for
String fqnTableForClass(TableWidget table) :
	let res = fqnGwtDto(table.for) : 
		debugTrace("fqnTableForClass() : table.for = " + table.for) ->
		debugTrace("fqnTableForClass() : res = " + res) ->
		res; // tableForClass(table)

Boolean widgetHasNameProp(ViewDataProperty prop) :
	if (prop.isDateOrDateTime()) then
		false
	else
		true;






// Copied from guihelper.ext
boolean isDateOrDateTime(Attribute attr) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.isDateOrDateTime(sculptormetamodel.TypedElement);

//	{"Date", "DateTime", "Timestamp", "LocalDate", "Time", "java.util.Date"}.contains(attr.type);
//	debugTrace("type is: " + attr.type) ->

String getToDomainConversionExpression(TypedElement attr, String dtoAccessorExpr, String domainObjAccessorExpr) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.getToDomainConversionExpression(sculptormetamodel.TypedElement, java.lang.String, java.lang.String);

String getToDtoConversionExpression(TypedElement attr, String domainObjAccessorExpr) :
    JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.getToDtoConversionExpression(sculptormetamodel.TypedElement, java.lang.String);



// my own addition
boolean isBoolean(ViewDataProperty prop) :
	{"Boolean"}.contains(prop.getAttributeType());

String resolveGwtWidgetBinderReference(ViewDataProperty prop) :
	if (prop.isDateOrDateTime()) then
		"d:DateBox" // com.google.gwt.user.datepicker.client.DateBox
	else if (prop.isBoolean()) then
		"g:CheckBox"
	else 
		"g:TextBox";

String fieldName(ViewDataProperty prop) :
	prop.name + "Field";

	
String getDtoPropertyPath(ViewDataProperty property, String objName) :
	objName + ".get" + property.name.toFirstUpper() + "()";

String getDtoPropertyPath(BasicTypeViewProperty property, String objName) :
	"(" + objName + ".get" + property.reference.name.toFirstUpper() + "()" + "== null ? null : " +
	objName + ".get" + property.reference.name.toFirstUpper() + "()" + '.' + "get" + property.attribute.name.toFirstUpper() + "())";

String getDtoPropertyPath(BasicTypeEnumViewProperty property, String objName) :
	"(" + objName + ".get" + property.basicTypeReference.name.toFirstUpper() + "()" + "== null ? null : " +
	objName + ".get" + property.basicTypeReference.name.toFirstUpper() + "()" + '.' + "get" + property.reference.name.toFirstUpper() + "())";



String fqnAddCommand(UserTask task) :
	gwtDomainPackage(task.for) + "." + "Add" + task.for.name.toFirstUpper();
	 
String fqnDeleteCommand(UserTask task) :
	gwtDomainPackage(task.for) + "." + "Delete" + task.for.name.toFirstUpper();
	 
	 
//
// General functions
//
String loggerDeclaration(String relativeClassName) :
    "private static final java.util.logging.Logger LOG = java.util.logging.Logger.getLogger(" + relativeClassName + ".class.getName());";

boolean generateGwt(DomainObject d) :
	d.getHint("gwt") != "skip";

boolean generateGwt(Reference r) :
	r.getHint("gwt") != "skip";

boolean generateGwt(Attribute a) :
	a.getHint("gwt") != "skip";

List[DomainObject] gwtDomainObjects(Module m):
	m.domainObjects.select(d|d.generateGwt());

List[Attribute] gwtAttributes(DomainObject d):
	d.attributes.select(a|a.generateGwt());

List[Reference] gwtReference(DomainObject d):
	d.references.select(r|r.generateGwt());

	 
//
// Mapping-related functions
//

String mapToDomainCall(Reference ref) :
	dtoMapper(ref.to.module) + ".mapToDomain";

String mapFromDomainCall(Reference ref) :
	dtoMapper(ref.to.module) + ".mapFromDomain";
	
String mapFromDomainCall(DomainObject do) :
	do.module.dtoMapper() + ".map" + do.name + "FromDomain";

// Package for server-side domain mapper classes
String gwtDomainMaperPackage(DomainObject do) :
	do.getDomainPackage();

String mapperClassName(Module m) :
	m.name.toFirstUpper() + "DtoMapper";
	
//String fqnMapperClass(DomainObject m) :
//	m.getDomainPackage() + "." + m.mapperClassName();
	

// Fully qualified class of mapper for given Module
String dtoMapper(Module module) :
	JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.dtoMapper(sculptormetamodel.Module);

boolean isMappableType(Parameter parameter) :
	JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.isMappableType(sculptormetamodel.Parameter);

String getMapToDomainExpression(Parameter parameter) :
	JAVA org.fornax.cartridges.sculptor.gwt.generator.util.GwtGenerationHelper.getMapToDomainExpression(sculptormetamodel.Parameter);

// The set of domain objects for which GWT<->core mapping code should be generated
boolean shouldBeMapped(DomainObject d) :
	 generateGwt(d) &&
	 GuiDto.isInstance(d);
//	(Entity.isInstance(d) || (ValueObject.isInstance(d) && !DomainEvent.isInstance(d)) || Enum.isInstance(d));



////////////////////////////////////////////////////////////////////////////
// GWT module XML config related functions
////////////////////////////////////////////////////////////////////////////

String gwtXmlFileName(GuiModule module) :
    module.gwtBasePackage().replaceAll("\\.", "/") + "/" + module.getModuleConfigName() + ".gwt.xml";

String gwtImplXmlFileName(GuiModule module) :
    module.gwtBasePackage().replaceAll("\\.", "/") + "/" + module.getModuleImplConfigName() + ".gwt.xml";
   
String getModuleConfigName(GuiModule module) :
	module.name.toFirstUpper() + "BaseUI";

String getModuleImplConfigName(GuiModule module) :
	module.name.toFirstUpper() + "UI";



String fqnModuleConfig(GuiModule module) :
	module.gwtBasePackage() + "." + module.getModuleConfigName();
   
String fqnImplModuleConfig(GuiModule module) :
	module.gwtBasePackage() + "." + module.getModuleImplConfigName();

String moduleGwtMain(GuiModule module) :
    module.gwtBasePackage() + ".client." + module.name.toFirstUpper() + "UI";
	

////////////////////////////////////////////////////////////////////////////
// Widget naming-related functions
////////////////////////////////////////////////////////////////////////////
String widgetClickHandlersExpr(Widget w) :
	"get" + w.name.toFirstUpper() + "HasClickHandlers()";
   
String widgetForIsWidgetExpr(Widget w) :
	"get" + w.name.toFirstUpper() + "ForIsWidget()";




////////////////////////////////////////////////////////////////////////////
// View-related functions
////////////////////////////////////////////////////////////////////////////

boolean usePresenterCallbacks(View view) :
	hasHint(view, "gwtpresentercallbacks");

String presenterCallbackMethodName(TableWidget tableWidget, TableColumn column, BehaviorBinding binding) :
	tableWidget.name + column.name.toFirstUpper() + binding.bindingTypeName;

//cached List[Widget] allWidgets(View view) :
//	allContainedWidgets(view);

// Return all the contained widgets, and all their contained widgets, but not the containing widget itself
//List[Widget] allContainedWidgets(WidgetsContainer container) :
//	{}.addAll(container.widgets).addAll(container.widgets.allContainedWidgets().flatten());

//List[Widget] allContainedWidgets(TableWidget table) :
//	{}.addAll(table.columns.typeSelect(WidgetTableColumn));

//List[Widget] allContainedWidgets(Widget widget) :
//	{widget};
		
String getViewRootBaseClass(View view) :
	getProperty("gwt.view.base");

// GWT view widget base class relative name
String gwtViewWidgetBaseClass(View view) :
	view.name.toFirstUpper() + "ViewBase";

// GWT view base UI Binder class relative name
String gwtViewWidgetBaseUiBinderClass(View view) :
	view.gwtViewWidgetBaseClass() + "UiBinder";

// Fully qualified name of GWT widget UI binder class corresponding to the given view
String fqnViewWidgetBaseUiBinderClass(View view) :
	view.gwtBaseWidgetsPackage() + "." + view.gwtViewWidgetBaseUiBinderClass() ;


// GWT view widget base interface relative name
String gwtViewBaseInterface(View view) :
	view.name.toFirstUpper() + "ViewBaseIf";

// Fully qualified name of GWT view base widget interface
String fqnGwtViewBaseInterface(View view) :
	view.gwtBaseWidgetsPackage() + "." + view.gwtViewBaseInterface();

// GWT view widget interface relative name
String gwtViewInterface(View view) :
	view.name.toFirstUpper() + "ViewIf";

// Fully qualified name of GWT view widget interface
String fqnGwtViewInterface(View view) :
	view.gwtWidgetsPackage() + "." + view.gwtViewInterface();


	
// GWT view widget impl class relative name
String gwtViewWidgetImplClass(View view) :
	view.name.toFirstUpper() + "ViewImpl";

// Fully qualified name of GWT widget base class corresponding to the given view
String fqnGwtViewWidgetBaseClass(View view) :
	view.gwtBaseWidgetsPackage() + "." + view.gwtViewWidgetBaseClass() ;

// Fully qualified name of GWT widget impl class corresponding to the given view
String fqnGwtViewWidgetImplClass(View view) :
	view.gwtWidgetsPackage() + "." + view.gwtViewWidgetImplClass() ;

String gwtPresenterBaseInterface(View view) :
	view.name.toFirstUpper() + "BasePresenterIf";
	
// Fully qualified name of the GWT presenter interface for a view
String fqnPresenterBaseInterface(View view) :
	view.gwtActivitiesBasePackage() + "." + view.gwtPresenterBaseInterface();

String gwtPresenterInterface(View view) :
	view.name.toFirstUpper() + "PresenterIf";
	
// Fully qualified name of the GWT presenter interface for a view
String fqnPresenterInterface(View view) :
	view.gwtActivitiesPackage() + "." + view.gwtPresenterInterface();


	

Set[Service] getUsedServices(GuiModule module) :
	module.serviceDependencies;

	
Set[Service] getUsedServices(View view) :
	{}.addAll(view.serviceDependencies);
//	(task.getPrimaryService() == null ? {} : {}.add(task.getPrimaryService())).
//		addAll(task.getServicesToSelectDomainObjects()).toSet();


//////////////////////////////////////////////////////////////////////////////
// General widget functions
//////////////////////////////////////////////////////////////////////////////
String getTypedWidgetTargetType(PropertyReferringWidget widget) :
	widget.for != null ? widget.for.fqnGwtDto() : "String";
	
String getTypedWidgetTargetType(ListBoxWidget widget) :
	widget.forEnum != null ? widget.forEnum.fqnGwtDto() : 
		(widget.for != null ? widget.for.fqnGwtDto() : "String");


// Return whether widget is modifyable (and clearable) or not
	
Boolean isModifyable(Widget widget):
	false;

Boolean isModifyable(InputTextWidget widget):
	true;

Boolean isModifyable(PanelWidget widget):
	true;

Boolean isModifyable(TableWidget widget):
	true;

Boolean isModifyable(RadioButtonsWidget widget):
	true;


// The type to be used for cell table Columns - what data type the column is holding
String cellTableColumnType(Widget colWidget, TableColumn col) :
	colWidget.widgetType != null ? getCellColumnType(colWidget.widgetType, "String") : "String";

// Get the type that should be used for a parameterized Cell type.  This is really just getting used for
// enum-based ListBox right now.  Calling colWidget.getTypedWidgetTargetType() is there for EnumListBox.  This
// special case may go away when EnumListBox supports using column types of enums rather than Strings, so the
// column type will == cell parameterized type.
// TODO: This is messy - clean up
// This is only called if colWidget.forEnum != null
String cellParameterizedType(ListBoxWidget colWidget, TableColumn col) :
	colWidget.widgetType != null ? colWidget.cellTableColumnType(col) :
		colWidget.getTypedWidgetTargetType();



//String cellTableColumnType(ListBoxWidget colWidget, TableColumn col) :
//	(colWidget.forEnum != null && colWidget.widgetType == "psaEnumSelectionCell" ? "com.lfg.psa.gwt.framework.shared.PsaEnum" : "String");
	
	
//////////////////////////////////////////////////////////////////////////////
// Widget-related functions : resolveGwtWidgetType
//////////////////////////////////////////////////////////////////////////////

// If true, this is a 'provided' widget in terms of UiBinder (UiBinder isn't creating the widget - the view has to)
// false by default
Boolean isProvided(Widget widget):
	false;
	
Boolean isProvided(TableWidget tableWidget):
	true;
	
Boolean isProvided(ListBoxWidget widget):
	widget.forEnum != null;


String resolveGwtWidgetType(Widget widget) :
	error("Unexpected call to resolveGwtWidgetType: " + widget);

// TODO: Make the following methods use getWidgetType(String) instead - e.g. getWidgetType("inputdate")

String resolveGwtWidgetType(InputDateWidget widget) :
	getProperty("gwt.widget.inputdate.class");

String resolveGwtWidgetTag(InputDateWidget widget) :
	getProperty("gwt.widget.inputdate.tag");

String resolveGwtWidgetType(InputTextWidget widget) :
	getProperty("gwt.widget.inputtext.class");

String resolveGwtWidgetTag(InputTextWidget widget) :
	getProperty("gwt.widget.inputtext.tag");

String resolveGwtWidgetType(InformationalTextWidget widget) :
	getProperty("gwt.widget.informationaltext.class");

String resolveGwtWidgetTag(InformationalTextWidget widget) :
	getProperty("gwt.widget.informationaltext.tag");

String resolveGwtCellWidgetType(InformationalTextWidget widget) :
	resolveGwtCellWidgetTypeWithOverriding(widget, "informationalText");
	
String resolveGwtCellWidgetType(LinkWidget widget) :
	resolveGwtCellWidgetTypeWithOverriding(widget, "link");

String resolveGwtCellWidgetTypeWithOverriding(Widget widget, String defaultName) :
	(widget.widgetType != null ? getCellTypeClass(widget.widgetType) : getCellTypeClass(defaultName));


String resolveGwtWidgetType(ButtonWidget widget) :
	getProperty("gwt.widget.button.class");

String resolveGwtWidgetTag(ButtonWidget widget) :
	getProperty("gwt.widget.button.tag");
	

String resolveGwtWidgetType(AutocompleteWidget widget) :
	(widget.widgetType != null ? getWidgetType(widget.widgetType) : getWidgetType("autocomplete"));

String resolveGwtWidgetTag(AutocompleteWidget widget) :
	(widget.widgetType != null ? getWidgetTag(widget.widgetType) : getWidgetTag("autocomplete"));

String resolveGwtWidgetType(LinkWidget widget) :
	getProperty("gwt.widget.link.class");

String resolveGwtWidgetTag(LinkWidget widget) :
	getProperty("gwt.widget.link.tag");

String resolveGwtWidgetType(PanelWidget widget) :
	(widget.widgetType != null ? getWidgetType(widget.widgetType) : getWidgetType("panel"));

String resolveGwtWidgetTag(PanelWidget widget) :
	(widget.widgetType != null ? getWidgetTag(widget.widgetType) : getWidgetTag("panel"));

String resolveGwtWidgetType(TableWidget widget) :
	(widget.widgetType != null ? getWidgetType(widget.widgetType) : getWidgetType("table"));

String resolveGwtWidgetTag(TableWidget widget) :
	(widget.widgetType != null ? getWidgetTag(widget.widgetType) : getWidgetTag("table"));

String resolveGwtWidgetType(ListBoxWidget widget) :
	if(widget.widgetType != null) then
		getTypedWidgetType(widget, widget.widgetType)
	else
		widget.forEnum != null? getWidgetType("enumListBox") + "<" + widget.forEnum.fqnGwtDto() + ">" :
			getTypedWidgetType(widget, "listBox");

// TODO: Clean up some of this forEnum vs for domain object stuff.  Can a widget be a typedWidget and have forEnum?
String getTypedWidgetType(PropertyReferringWidget widget, String modelType) :
	let widgetType = getWidgetType(modelType) :
		isTypedWidget(modelType) ? widgetType + "<" + widget.getTypedWidgetTargetType() + ">" : widgetType;
	
String resolveGwtWidgetTag(ListBoxWidget widget) :
	if(widget.widgetType != null) then
		getWidgetTag(widget.widgetType)
	else
		widget.forEnum != null? getWidgetTag("enumListBox") :
			getWidgetTag("listBox");

String resolveGwtWidgetType(CustomWidget widget) :
	(widget.widgetType != null ? getWidgetType(widget.widgetType) : getWidgetType("custom"));
		
String resolveGwtWidgetTag(CustomWidget widget) :
	if(widget.widgetType != null) then
		getWidgetTag(widget.widgetType)
	else
		getWidgetTag("custom");



	

//////////////////////////////////////////////////////////////////////////////
// Activity related functions
//////////////////////////////////////////////////////////////////////////////

// Package for all activity-related classes
gwtActivitiesPackage(View view) :
	gwtBasePackage(view.module) + ".client.activity";

// Package for all activity-related base classes (generated code)
gwtActivitiesBasePackage(View view) :
	gwtBasePackage(view.module) + ".client.gen.activity";




// GWT activity base class relative name
String gwtActivityBaseClass(View view) :
	view.name + "ActivityBase";

// Base class that should be used for all activities
String gwtFrameworkActivityBaseClass(View view) :
	getProperty("gwt.activity.base.class") + "<" + fqnPlaceBaseClass(view) + ">";
//	"com.google.gwt.activity.shared.AbstractActivity";


// GWT activity impl class relative name
String gwtActivityImplClass(View view) :
	view.name + "Activity";

// Fully qualified activity base class
String fqnActivityBaseClass(View view) :
	view.gwtActivitiesBasePackage() + "." + view.gwtActivityBaseClass() ;

// Fully qualified activity impl class
String fqnActivityImplClass(View view) :
	view.gwtActivitiesPackage() + "." + view.gwtActivityImplClass() ;

// Fully qualified activity impl class name

// Get name of behavior dispatcher attribute in activity
String behaviorDispatcherName(BehaviorBinding binding) :
	binding.widget.name + binding.bindingTypeName + "BehaviorDispatcher";
	

//////////////////////////////////////////////////////////////////////////////
// Place related functions
//////////////////////////////////////////////////////////////////////////////

String getPlaceArgConst(ViewParameter param) :
	param.name.toUpperCase() + "ARG";

// Package for all place-related non-generated classes
gwtPlacesPackage(View view) :
	gwtBasePackage(view.module) + ".client.place";


// Package for all place-related generated classes
gwtPlacesBasePackage(View view) :
	gwtBasePackage(view.module) + ".client.gen.place";


// GWT place base class relative name
String gwtPlaceBaseClass(View view) :
	view.name + "Place";

// Base class that should be used for all places
String gwtFrameworkPlaceBaseClass(View view) :
	getProperty("gwt.place.base.class");
	
// GWT place impl class relative name
//String gwtPlaceImplClass(View view) :
//	view.name + "Place";

// Fully qualified place base class
String fqnPlaceBaseClass(View view) :
	view.gwtPlacesBasePackage() + "." + view.gwtPlaceBaseClass() ;

// Until we're generating gap class
String fqnPlaceClass(View view) :
	fqnPlaceBaseClass(view);

// Fully qualified place impl class
//String fqnPlaceImplClass(View view) :
//	view.gwtPlacesPackage() + "." + view.gwtPlaceImplClass() ;

Collection[ViewParameter] requiredParameters(View view) :
	view.parameters.select(p | !p.nullable);


///////////////////////////////////////////////////////////////
// Event-related functions
///////////////////////////////////////////////////////////////
    
// Package for all event-related widget classes
gwtEventsPackage(GuiEvent event) :
	gwtBasePackage(event.guiModule) + ".client.event";
	
// GWT event base class relative name
String gwtEventBaseClass(GuiEvent event) :
	event.name + "Base";


fqnGwtEventBaseClass(GuiEvent event) :
	event.gwtEventsPackage() + "." + event.gwtEventBaseClass();

fqnGwtEventClass(GuiEvent event) :
	event.gwtEventsPackage() + "." + event.gwtEventClass();
	
// GWT event handler class relative name
String gwtEventHandlerClass(GuiEvent event) :
	event.name + "Handler";	

String fqnEventHandlerClass(GuiEvent event) :
	gwtEventsPackage(event) + "." + gwtEventBaseClass(event) + "." + gwtEventHandlerClass(event);
	
// GWT event concrete class relative name
String gwtEventClass(GuiEvent event) :
	event.name;



	
Set[GuiCommand] commandsToGenerate(GuiModule module) :
	module.stubModule.domainObjects.select(c | GuiCommand.isInstance(c)).reject(c | ! generateGwt(c));
	








boolean hasSourceRef(PropertyReferringWidget widget) :
	widget.forOp != null || widget.forProperty != null || widget.propertyPath != null;
	
// Get the proper expression to access the domain object property pointed to by widget, contained in obj, with local name instName
String getSourceRefExpression(PropertyReferringWidget widget, GuiDto obj, String instName) :
	switch {
		case widget.forOp != null : widget.forOp.getAccessor(instName)
		
		// TODO: Following should handle nested path expressions
		case widget.propertyPath != null : getPathExpression(instName, obj, widget.propertyPath)
		
		case widget.forProperty != null : instName + "." + getPropertyPathExpression(widget.forProperty)
		
		default : null
	};
		

String getPropertyPathExpression(PropertyPathElement pathElem) :
	pathElem.getPropertyPathElementExpression() +
		(pathElem.remainingPath != null ? "." + pathElem.remainingPath.getPropertyPathExpression() : "");
	
String getPropertyPathElementExpression(PropertyPathElement pathElem) :
	switch {
		case pathElem.forAttribute != null : pathElem.forAttribute.getGetAccessor() + "()"
		
		case pathElem.forReference != null : pathElem.forReference.getGetAccessor() + "()"
		default : ""
	};

String getPathExpression(String instName, DomainObject obj, String propertyPath) :
	instName + "." + obj.getElementByName(propertyPath).getGetAccessor() + "()";

String getSetterPathExpression(String instName, DomainObject obj, String propertyPath) :
	let targetElem = obj.getElementByName(propertyPath) :
		debugTrace("getSetterPathExpression() targetElem.to = " + targetElem.to) ->
		if(Enum.isInstance(targetElem.to)) then
			instName + "." + obj.getElementByName(propertyPath).getSetAccessor() + "AsString"
		else
			instName + "." + obj.getElementByName(propertyPath).getSetAccessor();

// TODO: Move to helpers.ext?
String getSetAccessor(NamedElement element) :
    "set" + element.name.toFirstUpper();

		
NamedElement getElementByName(DomainObject obj, String name) :
	let res = obj.getAllAttributes().addAll(obj.getAllReferences()).select(e|e.name == name) :
		debugTrace("getElementByName() name = " + name + ", obj = " + obj) ->
		(res.size > 0 ? res.get(0) : null);
	
// Get the proper expression to access the domain object property pointed to by widget, contained in instName
String getSourceRefExpression(PropertyReferringWidget widget, String instName) :
	getSourceRefExpression(widget, instName);

// (widget.forOp != null ? widget.forOp.ge :
//	widget.forAttribute != null ? widget.forAttribute.getGetAccessor() :
//	widget.forReference != null ? widget.forReference.getGetAccessor() : null);

	
String getAccessor(DomainObjectOperation op, String instName) :
	instName + "." + op.name + "()";
	
	

	
	
// TODO: For now.
boolean needsBuilder(GuiCommand guiCommand) :
	false;
	

	
boolean passThruGwtException(String exc) :
	getGwtPassThruExceptions().contains(exc);
	
cached Collection[String] getGwtPassThruExceptions() :
    getProperty("gwt.exception.passthru").split(",");
		